import { Client, GatewayIntentBits, EmbedBuilder, TextChannel, ActionRowBuilder, ButtonBuilder, ButtonStyle, ButtonInteraction } from 'discord.js'
import { DateTime } from 'luxon'
import env from '#start/env'
import logger from '@adonisjs/core/services/logger'

interface CommandeData {
  id: number
  numero_commande: string
  statut: string
  total: number
  date_commande: string
  creneaux_livraison?: any
  type_livraison?: string
  user: {
    email: string
    prenom?: string
    nom?: string
  }
  entreprise: {
    nom: string
  }
  produits: Array<{
    nom: string
    quantite: number
    prix_unitaire: number
  }>
}

class DiscordService {
  private static instance: DiscordService | null = null
  private client: Client | null = null
  private channelId: string | undefined
  private isConnected: boolean = false
  private readyPromise: Promise<void> | null = null
  private processedInteractions: Set<string> = new Set()
  private botId: string = Math.random().toString(36).substring(7)

  constructor() {
    this.channelId = env.get('DISCORD_CHANNEL_ID')
    logger.info(`ü§ñ Bot Discord instance cr√©√©e avec ID: ${this.botId}`)
  }

  static getInstance(): DiscordService {
    if (!DiscordService.instance) {
      DiscordService.instance = new DiscordService()
    }
    return DiscordService.instance
  }

  /**
   * Initialise la connexion Discord
   */
  public async initialize(): Promise<void> {
    try {
      const token = env.get('DISCORD_BOT_TOKEN')
      
      if (!token) {
        logger.warn('Discord bot token not configured, Discord service disabled')
        return
      }

      if (!this.channelId) {
        logger.warn('Discord channel ID not configured, Discord service disabled')
        return
      }

      // Si d√©j√† connect√©, ne pas reconnecter
      if (this.client && this.isConnected) {
        logger.info('Discord bot d√©j√† connect√©')
        return
      }

      this.client = new Client({
        intents: [
          GatewayIntentBits.Guilds,
          GatewayIntentBits.GuildMessages,
        ]
      })

      // Cr√©er une promesse qui se r√©sout quand le bot est pr√™t
      this.readyPromise = new Promise((resolve) => {
        this.client!.once('ready', () => {
          logger.info(`Discord bot connect√© en tant que ${this.client?.user?.tag}`)
          this.isConnected = true
          resolve()
        })
      })

      // G√©rer les interactions de boutons
      this.client.on('interactionCreate', async (interaction) => {
        if (!interaction.isButton()) return
        
        await this.handleButtonInteraction(interaction)
      })

      this.client.on('error', (error) => {
        logger.error('Erreur Discord:', error)
        this.isConnected = false
      })

      await this.client.login(token)
      
      // Attendre que le bot soit vraiment pr√™t
      await this.readyPromise
      
    } catch (error) {
      logger.error('Erreur lors de l\'initialisation du service Discord:', error)
    }
  }

  /**
   * Assure que le bot est pr√™t avant d'envoyer des messages
   */
  private async ensureReady(): Promise<boolean> {
    if (!this.client) {
      logger.info('üîÑ Initialisation du client Discord...')
      await this.initialize()
      // Attendre un peu apr√®s l'initialisation
      await new Promise(resolve => setTimeout(resolve, 1000))
    }

    if (!this.isConnected) {
      logger.info('‚è≥ Attente de la connexion Discord...')
      if (this.readyPromise) {
        await this.readyPromise
      } else {
        // R√©initialiser si n√©cessaire
        await this.initialize()
      }
      // Attendre encore un peu pour √™tre s√ªr
      await new Promise(resolve => setTimeout(resolve, 500))
    }

    return this.isConnected && this.client !== null
  }

  /**
   * Envoie une notification de nouvelle commande
   */
  public async notifyNewCommande(commande: CommandeData): Promise<void> {
    logger.info('üîÑ Tentative d\'envoi de notification Discord...')
    
    // Assurer que le bot est pr√™t
    const isReady = await this.ensureReady()
    if (!isReady) {
      logger.error('‚ùå Impossible de connecter le bot Discord')
      return
    }

    try {
      const channel = await this.getChannel()
      if (!channel) {
        logger.error('‚ùå Impossible de r√©cup√©rer le canal Discord')
        return
      }

      logger.info(`üì§ Envoi du message vers le canal ${this.channelId}...`)
      const embed = this.createCommandeEmbed(commande, 'üÜï Nouvelle Commande', 0x00ff00)
      const buttons = this.createCommandeButtons(commande.id, commande.statut)
      
      const message = await channel.send({ 
        embeds: [embed],
        components: buttons
      })

      // Sauvegarder l'ID du message Discord dans la commande
      try {
        const { default: Commande } = await import('#models/commande')
        const commandeModel = await Commande.find(commande.id)
        if (commandeModel) {
          commandeModel.discordMessageId = message.id
          await commandeModel.save()
        }
      } catch (dbError) {
        logger.error('Erreur lors de la sauvegarde de l\'ID du message Discord:', dbError)
      }
      
      logger.info(`‚úÖ Notification Discord envoy√©e avec succ√®s ! Message ID: ${message.id}`)
    } catch (error) {
      logger.error('‚ùå Erreur lors de l\'envoi de la notification Discord:', error)
      // Log plus d√©taill√© de l'erreur
      if (error instanceof Error) {
        logger.error(`   Message: ${error.message}`)
        logger.error(`   Stack: ${error.stack}`)
      }
    }
  }

  /**
   * Envoie une notification de mise √† jour de commande
   */
  public async notifyCommandeUpdate(commande: CommandeData, oldStatut: string): Promise<void> {
    if (!this.isReady()) return

    try {
      // Essayer de trouver le thread de la commande
      const thread = await this.findOrCreateThread(commande.numero_commande)
      
      if (thread) {
        // Envoyer dans le thread
        const actionEmbed = this.createActionEmbed('update', 'System', commande.numero_commande, commande.statut)
        await thread.send({ embeds: [actionEmbed] })
        logger.info(`üì§ Message de mise √† jour envoy√© dans le thread pour la commande #${commande.id}`)
      } else {
        // Fallback: envoyer dans le canal principal
        const channel = await this.getChannel()
        if (!channel) return

        const color = this.getStatusColor(commande.statut)
        const embed = this.createCommandeEmbed(
          commande, 
          `üìù Commande Mise √† Jour (${oldStatut} ‚Üí ${commande.statut})`, 
          color
        )
        
        await channel.send({ embeds: [embed] })
        logger.info(`Notification Discord de mise √† jour envoy√©e pour la commande #${commande.id}`)
      }
      
    } catch (error) {
      logger.error('Erreur lors de l\'envoi de la notification de mise √† jour Discord:', error)
    }
  }

  /**
   * Envoie une notification de commande annul√©e
   */
  public async notifyCommandeCancelled(commande: CommandeData): Promise<void> {
    if (!this.isReady()) return

    try {
      // Essayer de trouver le thread de la commande
      const thread = await this.findOrCreateThread(commande.numero_commande)
      
      if (thread) {
        // Envoyer dans le thread
        const cancelEmbed = this.createActionEmbed('cancel', 'System', commande.numero_commande, 'annulee')
        await thread.send({ embeds: [cancelEmbed] })
        logger.info(`üì§ Message d'annulation envoy√© dans le thread pour la commande #${commande.id}`)
      } else {
        // Fallback: envoyer dans le canal principal
        const channel = await this.getChannel()
        if (!channel) return

        const embed = this.createCommandeEmbed(commande, '‚ùå Commande Annul√©e', 0xff0000)
        await channel.send({ embeds: [embed] })
        logger.info(`Notification Discord d'annulation envoy√©e pour la commande #${commande.id}`)
      }
      
    } catch (error) {
      logger.error('Erreur lors de l\'envoi de la notification d\'annulation Discord:', error)
    }
  }

  /**
   * V√©rifie si le service Discord est pr√™t
   */
  private isReady(): boolean {
    if (!this.client || !this.isConnected) {
      logger.warn('Service Discord non disponible')
      return false
    }
    return true
  }

  /**
   * R√©cup√®re le canal Discord
   */
  private async getChannel(): Promise<TextChannel | null> {
    try {
      if (!this.channelId) {
        logger.error('‚ùå ID du canal Discord non configur√©')
        return null
      }

      logger.info(`üîç Recherche du canal Discord avec ID: ${this.channelId}`)
      
      if (!this.client) {
        logger.error('‚ùå Client Discord non disponible')
        return null
      }

      const channel = await this.client.channels.fetch(this.channelId)
      
      if (!channel) {
        logger.error(`‚ùå Canal Discord avec ID ${this.channelId} introuvable`)
        return null
      }

      if (!channel.isTextBased()) {
        logger.error(`‚ùå Le canal ${this.channelId} n'est pas un canal textuel`)
        return null
      }

      logger.info(`‚úÖ Canal Discord trouv√©: ${channel.type}`)
      return channel as TextChannel
    } catch (error) {
      logger.error('‚ùå Erreur lors de la r√©cup√©ration du canal Discord:', error)
      if (error instanceof Error) {
        logger.error(`   Message d'erreur: ${error.message}`)
      }
      return null
    }
  }

  /**
   * Convertit une valeur en number de mani√®re s√©curis√©e
   */
  private safeToNumber(value: any): number {
    if (typeof value === 'number') return value
    if (typeof value === 'string') return parseFloat(value) || 0
    if (value && typeof value.toString === 'function') return parseFloat(value.toString()) || 0
    return 0
  }

  /**
   * Cr√©e un embed pour les actions de statut
   */
  private createActionEmbed(action: string, username: string, numeroCommande: string, newStatut: string): EmbedBuilder {
    let title = ''
    let description = ''
    let color = 0x0099ff

    switch (action) {
      case 'claim':
        title = 'üôã‚Äç‚ôÇÔ∏è Commande Claim & Confirm√©e'
        description = `Commande prise en charge et confirm√©e par **${username}**`
        color = 0x0099ff // Bleu
        break
      case 'prepare':
        title = 'üë®‚Äçüç≥ Mise en Pr√©paration'
        description = `Commande mise en pr√©paration par **${username}**`
        color = 0xffff00 // Jaune
        break
      case 'ready':
        title = 'üì¶ Commande Pr√™te'
        description = `Commande pr√™te pour livraison par **${username}**`
        color = 0x9932cc // Violet
        break
      case 'deliver':
        title = 'üöö Commande Livr√©e'
        description = `Commande livr√©e avec succ√®s par **${username}**`
        color = 0x00ff00 // Vert
        break
      case 'cancel':
        title = '‚ùå Commande Annul√©e'
        description = `Commande annul√©e par **${username}**`
        color = 0xff0000 // Rouge
        break
      case 'update':
        title = 'üìù Mise √† Jour Automatique'
        description = `Statut de la commande mis √† jour automatiquement`
        color = 0x808080 // Gris
        break
      default:
        title = 'üìù Action sur Commande'
        description = `Action "${action}" effectu√©e par **${username}**`
        color = 0x808080 // Gris
    }

    const embed = new EmbedBuilder()
      .setTitle(title)
      .setDescription(description)
      .setColor(color)
      .addFields(
        { name: 'üìã N¬∞ Commande', value: numeroCommande, inline: true },
        { name: 'üìä Nouveau Statut', value: `${this.getStatusEmoji(newStatut)} ${newStatut.toUpperCase()}`, inline: true },
        { name: 'üë§ Par', value: username, inline: true }
      )
      .setTimestamp()
      .setFooter({ text: 'HenhouseWEB - Suivi de commandes' })

    return embed
  }

  /**
   * Trouve ou cr√©e un thread pour une commande donn√©e
   */
  private async findOrCreateThread(commandeNumero: string, messageId?: string): Promise<any> {
    logger.info(`üéØ DEBUG findOrCreateThread: Recherche thread pour commande ${commandeNumero}, messageId: ${messageId}`)
    
    try {
      const channel = await this.getChannel()
      if (!channel) {
        logger.error(`üéØ DEBUG findOrCreateThread: ‚ùå Impossible de r√©cup√©rer le canal`)
        return null
      }

      logger.info(`üéØ DEBUG findOrCreateThread: Canal r√©cup√©r√©: ${channel.id}`)

      // Essayer de trouver un thread existant dans les threads actifs ET archiv√©s
      let thread = null
      try {
        logger.info(`üéØ DEBUG findOrCreateThread: R√©cup√©ration des threads...`)
        
        const activeThreads = await channel.threads.fetchActive()
        const archivedThreads = await channel.threads.fetchArchived()
        
        logger.info(`üéØ DEBUG findOrCreateThread: Threads actifs: ${activeThreads.threads.size}, archiv√©s: ${archivedThreads.threads.size}`)
        
        // Lister tous les threads pour debug
        activeThreads.threads.forEach((t, id) => {
          logger.info(`üéØ DEBUG findOrCreateThread: Thread actif: "${t.name}" (ID: ${id})`)
        })
        
        archivedThreads.threads.forEach((t, id) => {
          logger.info(`üéØ DEBUG findOrCreateThread: Thread archiv√©: "${t.name}" (ID: ${id})`)
        })
        
        // Chercher dans les threads actifs
        logger.info(`üéØ DEBUG findOrCreateThread: Recherche pattern "${commandeNumero}"...`)
        thread = activeThreads.threads.find(t => {
          const match = t.name.includes(commandeNumero)
          logger.info(`üéØ DEBUG findOrCreateThread: "${t.name}" match? ${match}`)
          return match
        })
        
        // Si pas trouv√©, chercher dans les threads archiv√©s
        if (!thread) {
          logger.info(`üéØ DEBUG findOrCreateThread: Pas trouv√© dans actifs, recherche dans archiv√©s...`)
          thread = archivedThreads.threads.find(t => {
            const match = t.name.includes(commandeNumero)
            logger.info(`üéØ DEBUG findOrCreateThread: Archiv√© "${t.name}" match? ${match}`)
            return match
          })
        }
        
        logger.info(`üîç Recherche thread ${commandeNumero} - Actifs: ${activeThreads.threads.size}, Archiv√©s: ${archivedThreads.threads.size}`)
        if (thread) {
          logger.info(`‚úÖ Thread existant trouv√©: ${thread.name} (ID: ${thread.id})`)
        } else {
          logger.info(`üéØ DEBUG findOrCreateThread: ‚ùå Aucun thread trouv√© avec pattern "CMD-${commandeNumero}"`)
        }
      } catch (error) {
        logger.error('üéØ DEBUG findOrCreateThread: ‚ùå Erreur r√©cup√©ration threads:', error)
        logger.error('üéØ DEBUG findOrCreateThread: Message:', error.message)
      }

      // Si aucun thread n'existe et qu'on a un messageId, essayer de cr√©er un thread
      if (!thread && messageId) {
        logger.info(`üéØ DEBUG findOrCreateThread: Pas de thread + messageId fourni, cr√©ation...`)
        try {
          const message = await channel.messages.fetch(messageId)
          logger.info(`üéØ DEBUG findOrCreateThread: Message r√©cup√©r√©: ${message?.id}`)
          
          if (message) {
            const threadName = `üìã Suivi Commande #${commandeNumero}`
            logger.info(`üéØ DEBUG findOrCreateThread: Cr√©ation thread "${threadName}"...`)
            
            thread = await message.startThread({
              name: threadName,
              autoArchiveDuration: 1440, // 24 heures
              reason: 'Suivi des actions sur la commande'
            })
            logger.info(`üßµ Thread cr√©√©: ${thread.name} (ID: ${thread.id})`)
          } else {
            logger.error(`üéØ DEBUG findOrCreateThread: ‚ùå Message non trouv√© avec ID ${messageId}`)
          }
        } catch (threadError) {
          logger.error('‚ùå Erreur lors de la cr√©ation du thread:', threadError)
          logger.error('üéØ DEBUG findOrCreateThread: Code:', threadError.code)
          logger.error('üéØ DEBUG findOrCreateThread: Message:', threadError.message)
          logger.error('üéØ DEBUG findOrCreateThread: Stack:', threadError.stack)
        }
      } else if (!thread && !messageId) {
        logger.warn(`üéØ DEBUG findOrCreateThread: Pas de thread ET pas de messageId`)
      }

      logger.info(`üéØ DEBUG findOrCreateThread: R√©sultat final: ${thread ? `Thread "${thread.name}" (${thread.id})` : 'null'}`)
      return thread
    } catch (error) {
      logger.error('‚ùå Erreur lors de la recherche/cr√©ation du thread:', error)
      logger.error('üéØ DEBUG findOrCreateThread: Erreur g√©n√©rale:', error.message)
      return null
    }
  }

  /**
   * Cr√©e un embed pour une commande
   */
  private createCommandeEmbed(commande: CommandeData, title: string, color: number, claimedBy?: string | null): EmbedBuilder {
    const userName = commande.user.prenom && commande.user.nom 
      ? `${commande.user.prenom} ${commande.user.nom}`
      : commande.user.email

    const produitsText = commande.produits.map(p => 
      `‚Ä¢ ${p.nom} (x${p.quantite}) - ${(p.quantite * this.safeToNumber(p.prix_unitaire)).toFixed(2)}$`
    ).join('\n')

    // Formatage des cr√©neaux de livraison
    let creneauxText = 'Non sp√©cifi√©'
    if (commande.creneaux_livraison) {
      try {
        const creneaux = typeof commande.creneaux_livraison === 'string' 
          ? JSON.parse(commande.creneaux_livraison) 
          : commande.creneaux_livraison
        
        if (creneaux && typeof creneaux === 'object') {
          const parts = []
          if (creneaux.date) parts.push(`üìÖ ${creneaux.date}`)
          if (creneaux.heure_debut && creneaux.heure_fin) {
            parts.push(`üïê ${creneaux.heure_debut} - ${creneaux.heure_fin}`)
          }
          if (parts.length > 0) {
            creneauxText = parts.join(' | ')
          }
        }
      } catch (error) {
        creneauxText = 'Format invalide'
      }
    }

    // Formatage du type de livraison
    const typeLivraisonEmoji = commande.type_livraison === 'livraison' ? 'üöö' : 'üè™'
    const typeLivraisonText = commande.type_livraison === 'livraison' ? 'Livraison' : 'Click & Collect'

    const embed = new EmbedBuilder()
      .setTitle(title)
      .setColor(color)
      .addFields(
        { name: 'üÜî ID', value: `#${commande.id}`, inline: true },
        { name: 'üìã N¬∞ Commande', value: commande.numero_commande || 'N/A', inline: true },
        { name: 'üë§ Client', value: userName, inline: true },
        { name: 'üè¢ Entreprise', value: commande.entreprise.nom || 'Commande publique', inline: true },
        { name: 'üìä Statut', value: this.getStatusEmoji(commande.statut) + ' ' + commande.statut, inline: true },
        { name: 'üí∞ Total', value: `${this.safeToNumber(commande.total).toFixed(2)}$`, inline: true },
        { name: 'üìÖ Date commande', value: new Date(commande.date_commande).toLocaleDateString('fr-FR'), inline: true },
        { name: `${typeLivraisonEmoji} Type`, value: typeLivraisonText, inline: true },
        { name: 'üöö Cr√©neau livraison', value: creneauxText, inline: false }
      )

    // Ajouter le champ "Claim par" si applicable
    if (claimedBy) {
      embed.addFields({ name: 'üôã‚Äç‚ôÇÔ∏è Claim par', value: claimedBy, inline: true })
    }

    embed.addFields({ name: 'üõçÔ∏è Produits', value: produitsText || 'Aucun produit', inline: false })
      .setTimestamp()
      .setFooter({ text: 'HenhouseWEB - Syst√®me de commandes' })

    return embed
  }

  /**
   * Retourne la couleur selon le statut
   */
  private getStatusColor(statut: string): number {
    switch (statut.toLowerCase()) {
      case 'en_attente':
        return 0xffa500 // Orange
      case 'confirmee':
        return 0x0099ff // Bleu
      case 'en_preparation':
        return 0xffff00 // Jaune
      case 'prete':
        return 0x9932cc // Violet
      case 'livree':
        return 0x00ff00 // Vert
      case 'annulee':
        return 0xff0000 // Rouge
      default:
        return 0x808080 // Gris
    }
  }

  /**
   * Cr√©e les boutons pour g√©rer une commande
   */
  private createCommandeButtons(commandeId: number, statut: string): ActionRowBuilder<ButtonBuilder>[] {
    const row1 = new ActionRowBuilder<ButtonBuilder>()
    const row2 = new ActionRowBuilder<ButtonBuilder>()

    // Bouton Claim (seulement si en_attente) - confirme directement
    if (statut === 'en_attente') {
      row1.addComponents(
        new ButtonBuilder()
          .setCustomId(`claim_${commandeId}`)
          .setLabel('üôã‚Äç‚ôÇÔ∏è Claim & Confirmer')
          .setStyle(ButtonStyle.Primary)
      )
    }

    // Boutons de progression selon le statut
    if (statut === 'confirmee' || statut === 'en_preparation') {
      row1.addComponents(
        new ButtonBuilder()
          .setCustomId(`prepare_${commandeId}`)
          .setLabel('üë®‚Äçüç≥ En pr√©paration')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(statut === 'en_preparation')
      )
    }

    if (statut === 'en_preparation' || statut === 'prete') {
      row2.addComponents(
        new ButtonBuilder()
          .setCustomId(`ready_${commandeId}`)
          .setLabel('üì¶ Pr√™te')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(statut === 'prete')
      )
    }

    if (statut === 'prete') {
      row2.addComponents(
        new ButtonBuilder()
          .setCustomId(`deliver_${commandeId}`)
          .setLabel('üöö Livr√©e')
          .setStyle(ButtonStyle.Success)
      )
    }

    // Bouton annuler (toujours disponible sauf si d√©j√† annul√©e ou livr√©e)
    if (!['annulee', 'livree'].includes(statut)) {
      row2.addComponents(
        new ButtonBuilder()
          .setCustomId(`cancel_${commandeId}`)
          .setLabel('‚ùå Annuler')
          .setStyle(ButtonStyle.Danger)
      )
    }

    const rows = []
    if (row1.components.length > 0) rows.push(row1)
    if (row2.components.length > 0) rows.push(row2)
    
    return rows
  }

  /**
   * G√®re les interactions de boutons
   */
  private async handleButtonInteraction(interaction: ButtonInteraction): Promise<void> {
    logger.info(`üîÑ [${this.botId}] Interaction re√ßue: ${interaction.customId} par ${interaction.user.username}`)
    logger.info(`üéØ DEBUG: Interaction ID: ${interaction.id}`)
    logger.info(`üéØ DEBUG: Guild ID: ${interaction.guildId}`)
    logger.info(`üéØ DEBUG: Channel ID: ${interaction.channelId}`)
    logger.info(`üéØ DEBUG: User ID: ${interaction.user.id}`)
    logger.info(`üéØ DEBUG: √âtat initial - deferred: ${interaction.deferred}, replied: ${interaction.replied}`)
    
    // V√©rifier l'√¢ge de l'interaction
    const interactionAge = Date.now() - interaction.createdTimestamp
    logger.info(`üéØ DEBUG: √Çge de l'interaction: ${interactionAge}ms`)
    logger.info(`üéØ DEBUG: Timestamp actuel: ${Date.now()}, Timestamp interaction: ${interaction.createdTimestamp}`)
    
    // V√©rifier si l'interaction a d√©j√† √©t√© trait√©e
    if (interaction.deferred || interaction.replied) {
      logger.warn(`‚ö†Ô∏è Interaction d√©j√† trait√©e - deferred: ${interaction.deferred}, replied: ${interaction.replied}`)
      return
    }
    
    // V√©rifier si on a d√©j√† trait√© cette interaction (d√©duplication)
    if (this.processedInteractions.has(interaction.id)) {
      logger.warn(`‚ö†Ô∏è [${this.botId}] Interaction d√©j√† trait√©e par cette instance: ${interaction.id}`)
      return
    }
    
    // Marquer l'interaction comme en cours de traitement
    this.processedInteractions.add(interaction.id)
    logger.info(`üéØ DEBUG: [${this.botId}] Interaction marqu√©e comme en traitement`)
    
    // V√©rifier si l'interaction n'est pas trop ancienne (plus de 2 secondes)
    // TEMPORAIREMENT D√âSACTIV√â √† cause du probl√®me d'horloge
    if (Math.abs(interactionAge) > 5000) { // Utiliser Math.abs et augmenter la tol√©rance
      logger.warn(`‚ö†Ô∏è Interaction trop ancienne/future (${interactionAge}ms), abandon`)
      this.processedInteractions.delete(interaction.id)
      return
    }
    
    try {
      logger.info(`üéØ DEBUG: Tentative de defer reply...`)
      // D√©f√©rer la r√©ponse imm√©diatement pour avoir plus de temps (15 minutes au lieu de 3 secondes)
      
      try {
        await interaction.deferReply({ flags: 64 }) // MessageFlags.Ephemeral
        logger.info(`üéØ DEBUG: ‚úÖ Defer reply r√©ussi !`)
      } catch (deferError: any) {
        if (deferError.code === 10062) { // Unknown interaction
          logger.warn(`‚ö†Ô∏è Interaction expir√©e avant defer, tentative de reply direct...`)
          try {
            await interaction.reply({ 
              content: '‚è±Ô∏è Traitement en cours...', 
              flags: 64 
            })
            logger.info(`üéØ DEBUG: ‚úÖ Reply direct r√©ussi comme fallback`)
          } catch (fallbackError) {
            logger.error(`‚ùå Impossible de r√©pondre √† l'interaction expir√©e:`, fallbackError)
            this.processedInteractions.delete(interaction.id)
            return
          }
        } else {
          throw deferError // Re-lancer si ce n'est pas une expiration
        }
      }
      
      logger.info(`üéØ DEBUG: Parsing custom ID...`)
      const [action, commandeIdStr] = interaction.customId.split('_')
      const commandeId = parseInt(commandeIdStr)

      logger.info(`üîç Action: ${action}, ID Commande: ${commandeId}`)
      logger.info(`üéØ DEBUG: Custom ID split result: action="${action}", commandeIdStr="${commandeIdStr}"`)

      if (isNaN(commandeId)) {
        logger.error(`‚ùå ID de commande invalide: ${commandeIdStr}`)
        logger.info(`üéØ DEBUG: Tentative d'edit reply pour erreur ID invalide...`)
        await interaction.editReply({ 
          content: '‚ùå ID de commande invalide'
        })
        logger.info(`üéØ DEBUG: ‚úÖ Edit reply erreur r√©ussi`)
        return
      }
      
      logger.info(`üéØ DEBUG: Import du mod√®le Commande...`)
      // Importer le mod√®le Commande ici pour √©viter les d√©pendances circulaires
      const { default: Commande } = await import('#models/commande')
      logger.info(`üéØ DEBUG: ‚úÖ Mod√®le Commande import√©`)
      
      logger.info(`üîé Recherche de la commande ${commandeId}...`)
      const commande = await Commande.find(commandeId)
      logger.info(`üéØ DEBUG: R√©sultat de la recherche: ${commande ? `trouv√©e (statut: ${commande.statut})` : 'non trouv√©e'}`)
      
      if (!commande) {
        logger.error(`‚ùå Commande ${commandeId} non trouv√©e`)
        logger.info(`üéØ DEBUG: Tentative d'edit reply pour commande non trouv√©e...`)
        await interaction.editReply({ 
          content: `‚ùå Commande #${commandeId} non trouv√©e`
        })
        logger.info(`üéØ DEBUG: ‚úÖ Edit reply commande non trouv√©e r√©ussi`)
        return
      }

      const oldStatut = commande.statut
      let newStatut = oldStatut

      logger.info(`üìä Statut actuel: ${oldStatut}`)

      // D√©terminer le nouveau statut selon l'action
      logger.info(`üéØ DEBUG: D√©but du switch avec action: ${action}`)
      switch (action) {
        case 'claim':
          logger.info(`üéØ DEBUG: Action claim d√©tect√©e, statut actuel: ${commande.statut}`)
          if (commande.statut === 'en_attente') {
            logger.info(`üéØ DEBUG: Statut en_attente, processing claim...`)
            commande.claimedBy = interaction.user.username
            commande.claimedAt = DateTime.now()
            newStatut = 'confirmee'
          } else if (commande.statut === 'confirmee' && commande.claimedBy) {
            // Cas sp√©cial: la commande est d√©j√† claim mais le message Discord n'a pas √©t√© mis √† jour
            logger.info(`üîß DEBUG: Commande d√©j√† claim par ${commande.claimedBy}, r√©paration du message Discord...`)
            newStatut = 'confirmee' // Garder le statut actuel
            // Ne pas modifier claimedBy car c'est d√©j√† fait
          } else {
            logger.info(`üéØ DEBUG: Statut != en_attente et pas r√©parable, envoi message d'erreur`)
            await interaction.editReply({ 
              content: '‚ùå Cette commande ne peut plus √™tre claim'
            })
            logger.info(`üéØ DEBUG: ‚úÖ EditReply erreur claim envoy√©`)
            
            // IMPORTANT: Toujours nettoyer le cache m√™me en cas d'erreur
            this.processedInteractions.delete(interaction.id)
            return
          }
          break

        case 'prepare':
          if (commande.statut === 'confirmee') {
            newStatut = 'en_preparation'
          } else if (commande.statut === 'en_preparation') {
            logger.info(`üîß DEBUG: Commande d√©j√† en pr√©paration, r√©paration du message Discord...`)
            newStatut = 'en_preparation' // Garder le statut actuel
          } else {
            await interaction.editReply({ content: '‚ùå Cette commande ne peut pas √™tre mise en pr√©paration' })
            this.processedInteractions.delete(interaction.id)
            return
          }
          break

        case 'ready':
          if (commande.statut === 'en_preparation') {
            newStatut = 'prete'
          } else if (commande.statut === 'prete') {
            logger.info(`üîß DEBUG: Commande d√©j√† pr√™te, r√©paration du message Discord...`)
            newStatut = 'prete' // Garder le statut actuel
          } else {
            await interaction.editReply({ content: '‚ùå Cette commande ne peut pas √™tre marqu√©e comme pr√™te' })
            this.processedInteractions.delete(interaction.id)
            return
          }
          break

        case 'deliver':
          if (commande.statut === 'prete') {
            newStatut = 'livree'
          } else if (commande.statut === 'livree') {
            logger.info(`üîß DEBUG: Commande d√©j√† livr√©e, r√©paration du message Discord...`)
            newStatut = 'livree' // Garder le statut actuel
          } else {
            await interaction.editReply({ content: '‚ùå Cette commande ne peut pas √™tre marqu√©e comme livr√©e' })
            this.processedInteractions.delete(interaction.id)
            return
          }
          break

        case 'cancel':
          if (!['annulee', 'livree'].includes(commande.statut)) {
            newStatut = 'annulee'
          } else if (commande.statut === 'annulee') {
            logger.info(`üîß DEBUG: Commande d√©j√† annul√©e, r√©paration du message Discord...`)
            newStatut = 'annulee' // Garder le statut actuel
          } else {
            await interaction.editReply({ content: '‚ùå Cette commande ne peut pas √™tre annul√©e' })
            this.processedInteractions.delete(interaction.id)
            return
          }
          break

        default:
          logger.error(`‚ùå Action non reconnue: ${action}`)
          await interaction.editReply({ 
            content: '‚ùå Action non reconnue'
          })
          return
      }

      logger.info(`üîÑ Changement de statut: ${oldStatut} ‚Üí ${newStatut}`)

      // Mettre √† jour la commande seulement si le statut a chang√©
      if (oldStatut !== newStatut) {
        commande.statut = newStatut as any
        await commande.save()
        logger.info(`üíæ Commande sauvegard√©e avec le nouveau statut`)
      } else {
        logger.info(`üîß Pas de changement de statut, r√©paration du message Discord uniquement`)
      }

      // Recr√©er les donn√©es de commande et mettre √† jour le message
      const { default: User } = await import('#models/user')
      const { default: Entreprise } = await import('#models/entreprise')
      const Database = (await import('@adonisjs/lucid/services/db')).default

      logger.info(`üîÑ Reconstruction des donn√©es de commande...`)

      // Pour les commandes publiques, userId peut √™tre null
      let user = null
      if (commande.userId) {
        user = await User.findOrFail(commande.userId)
      }
      
      const entreprise = commande.entrepriseId ? await Entreprise.findOrFail(commande.entrepriseId) : null
      
      const commandeProduits = await Database
        .from('commande_produits')
        .join('produits', 'commande_produits.produit_id', 'produits.id')
        .where('commande_produits.commande_id', commandeId)
        .select(
          'produits.nom',
          'commande_produits.quantite',
          'commande_produits.prix_unitaire'
        )

      const commandeData: CommandeData = {
        id: commande.id,
        numero_commande: commande.numeroCommande,
        statut: newStatut, // Utiliser le NOUVEAU statut, pas l'ancien !
        total: this.safeToNumber(commande.total),
        date_commande: commande.createdAt.toString(),
        creneaux_livraison: commande.creneauxLivraison,
        type_livraison: commande.typeLivraison,
        user: {
          email: user ? user.username : commande.telephoneLivraison || 'Client anonyme',
          prenom: undefined,
          nom: undefined
        },
        entreprise: {
          nom: entreprise ? entreprise.nom : 'Commande publique'
        },
        produits: commandeProduits.map((p: any) => ({
          nom: p.nom,
          quantite: p.quantite,
          prix_unitaire: this.safeToNumber(p.prix_unitaire)
        }))
      }

      // Cr√©er le nouvel embed et les nouveaux boutons SEULEMENT pour la mise √† jour
      const statusTitle = `üìä Commande ${newStatut.toUpperCase()}`
      const statusColor = this.getStatusColor(newStatut)
      
      // Pour l'action claim, utiliser l'utilisateur actuel, sinon utiliser le claimedBy existant
      const displayClaimedBy = action === 'claim' ? interaction.user.username : commande.claimedBy
      const embed = this.createCommandeEmbed(commandeData, statusTitle, statusColor, displayClaimedBy)
      const buttons = this.createCommandeButtons(commandeId, newStatut)

      logger.info(`üîÑ Mise √† jour du message Discord...`)

      // Mettre √† jour SEULEMENT le message original (les boutons et le statut dans l'embed)
      logger.info(`üéØ DEBUG: D√©but de la mise √† jour du message original...`)
      const originalMessage = interaction.message
      logger.info(`üéØ DEBUG: Message original r√©cup√©r√©: ${originalMessage ? 'OUI' : 'NON'}`)
      
      if (originalMessage) {
        logger.info(`üéØ DEBUG: Tentative d'√©dition du message original...`)
        
        // S'assurer que l'embed refl√®te le nouveau statut et les informations de claim
        const updatedEmbed = this.createCommandeEmbed(
          commandeData, 
          statusTitle, 
          statusColor, 
          action === 'claim' ? interaction.user.username : commande.claimedBy
        )
        
        // S'assurer que les boutons refl√®tent le nouveau statut
        const updatedButtons = this.createCommandeButtons(commandeId, newStatut)
        
        await originalMessage.edit({
          embeds: [updatedEmbed],
          components: updatedButtons
        })
        logger.info(`üîÑ ‚úÖ Message original mis √† jour avec le nouveau statut: ${newStatut} et claimedBy: ${commande.claimedBy}`)
      } else {
        logger.warn(`‚ö†Ô∏è Impossible de mettre √† jour le message original - message non trouv√©`)
      }

      // üö® DEBUG: Cr√©er ou r√©cup√©rer le thread associ√© au message et envoyer SEULEMENT le message dans le thread
      logger.info(`üéØ DEBUG: D√©but de la gestion du thread pour l'action "${action}" sur commande #${commande.numeroCommande}`)
      try {
        let thread = null

        logger.info(`üéØ DEBUG: Message original ID: ${originalMessage?.id}`)
        logger.info(`üéØ DEBUG: Channel type: ${originalMessage?.channel?.type}`)
        logger.info(`üéØ DEBUG: Channel ID: ${originalMessage?.channel?.id}`)

        if (originalMessage && originalMessage.id) {
          // Essayer de r√©cup√©rer le thread existant de plusieurs fa√ßons
          try {
            const channel = originalMessage.channel
            logger.info(`üéØ DEBUG: Canal r√©cup√©r√©, v√©rification si c'est un canal avec threads...`)
            
            if ('threads' in channel) {
              logger.info(`üéØ DEBUG: ‚úÖ Le canal supporte les threads, r√©cup√©ration...`)
              
              // R√©cup√©rer tous les threads (actifs ET archiv√©s)
              const activeThreads = await channel.threads.fetchActive()
              logger.info(`üéØ DEBUG: Threads actifs r√©cup√©r√©s: ${activeThreads.threads.size}`)
              
              // Lister tous les threads actifs pour debug
              activeThreads.threads.forEach((t, id) => {
                logger.info(`üéØ DEBUG: Thread actif: "${t.name}" (ID: ${id})`)
              })
              
              const archivedThreads = await channel.threads.fetchArchived()
              logger.info(`üéØ DEBUG: Threads archiv√©s r√©cup√©r√©s: ${archivedThreads.threads.size}`)
              
              // Lister tous les threads archiv√©s pour debug
              archivedThreads.threads.forEach((t, id) => {
                logger.info(`üéØ DEBUG: Thread archiv√©: "${t.name}" (ID: ${id})`)
              })
              
              // Chercher dans les threads actifs
              logger.info(`üéØ DEBUG: Recherche du pattern "${commande.numeroCommande}" dans les threads actifs...`)
              thread = activeThreads.threads.find(t => {
                const match = t.name.includes(commande.numeroCommande)
                logger.info(`üéØ DEBUG: Thread "${t.name}" match ${commande.numeroCommande}? ${match}`)
                return match
              })
              
              // Si pas trouv√©, chercher dans les threads archiv√©s
              if (!thread) {
                logger.info(`üéØ DEBUG: Recherche du pattern "${commande.numeroCommande}" dans les threads archiv√©s...`)
                thread = archivedThreads.threads.find(t => {
                  const match = t.name.includes(commande.numeroCommande)
                  logger.info(`üéØ DEBUG: Thread archiv√© "${t.name}" match ${commande.numeroCommande}? ${match}`)
                  return match
                })
              }
              
              logger.info(`üîç Threads actifs: ${activeThreads.threads.size}, archiv√©s: ${archivedThreads.threads.size}`)
              if (thread) {
                logger.info(`‚úÖ Thread existant trouv√©: ${thread.name} (ID: ${thread.id})`)
              } else {
                logger.info(`üéØ DEBUG: ‚ùå Aucun thread trouv√© avec le pattern "CMD-${commande.numeroCommande}"`)
              }
            } else {
              logger.error(`üéØ DEBUG: ‚ùå Le canal ne supporte pas les threads`)
            }
          } catch (error) {
            logger.error('üéØ DEBUG: ‚ùå Erreur lors de la r√©cup√©ration des threads:', error)
            logger.error('üéØ DEBUG: D√©tails de l\'erreur:', error.message)
            logger.error('üéØ DEBUG: Stack:', error.stack)
          }

          // Si aucun thread n'existe, en cr√©er un SEULEMENT lors du premier claim
          if (!thread && action === 'claim') {
            logger.info(`üéØ DEBUG: Aucun thread trouv√© ET action = "claim", tentative de cr√©ation...`)
            try {
              const threadName = `üìã Suivi Commande #${commande.numeroCommande}`
              logger.info(`üéØ DEBUG: Nom du thread √† cr√©er: "${threadName}"`)
              logger.info(`üéØ DEBUG: Message utilis√© pour cr√©er le thread: ${originalMessage.id}`)
              
              thread = await originalMessage.startThread({
                name: threadName,
                autoArchiveDuration: 1440, // 24 heures
                reason: 'Suivi des actions sur la commande'
              })
              logger.info(`üßµ Thread cr√©√© avec succ√®s: ${thread.name} (ID: ${thread.id})`)
            } catch (threadError) {
              logger.error('‚ùå Erreur lors de la cr√©ation du thread:', threadError)
              logger.error('üéØ DEBUG: Code d\'erreur:', threadError.code)
              logger.error('üéØ DEBUG: Message d\'erreur:', threadError.message)
              logger.error('üéØ DEBUG: Stack complet:', threadError.stack)
            }
          } else if (!thread && action !== 'claim') {
            logger.warn(`üéØ DEBUG: Aucun thread trouv√© mais action="${action}" (pas claim), pas de cr√©ation`)
          } else if (thread) {
            logger.info(`üéØ DEBUG: Thread d√©j√† trouv√©, pas besoin de cr√©er`)
          }

          // Envoyer SEULEMENT le message dans le thread, PAS dans le channel principal
          if (thread) {
            logger.info(`üéØ DEBUG: Tentative d'envoi du message dans le thread...`)
            
            try {
              // Cr√©er un embed pour l'action
              const actionEmbed = this.createActionEmbed(action, interaction.user.username, commande.numeroCommande, newStatut)
              await thread.send({ embeds: [actionEmbed] })
              logger.info(`üì§ Message envoy√© dans le thread: ${thread.name}`)
            } catch (sendError) {
              logger.error('üéØ DEBUG: ‚ùå Erreur lors de l\'envoi du message dans le thread:', sendError)
              logger.error('üéØ DEBUG: D√©tails:', sendError.message)
            }
          } else {
            logger.warn(`‚ö†Ô∏è Aucun thread trouv√©/cr√©√© pour la commande #${commande.numeroCommande}`)
            logger.warn(`üéØ DEBUG: Action: ${action}, Thread null: ${thread === null}`)
          }
        } else {
          logger.error(`üéØ DEBUG: ‚ùå Pas de message original ou ID manquant`)
          logger.error(`üéØ DEBUG: originalMessage: ${!!originalMessage}`)
          logger.error(`üéØ DEBUG: originalMessage.id: ${originalMessage?.id}`)
        }
      } catch (threadError) {
        logger.error('‚ùå Erreur g√©n√©rale lors de la gestion du thread:', threadError)
        logger.error('üéØ DEBUG: Type d\'erreur:', threadError.constructor.name)
        logger.error('üéØ DEBUG: Message:', threadError.message)
        logger.error('üéØ DEBUG: Stack complet:', threadError.stack)
        // En cas d'erreur, NE PAS envoyer de message dans le channel principal
      }

      // Confirmer l'action √† l'utilisateur
      const isRepair = oldStatut === newStatut
      const confirmMessage = isRepair 
        ? `üîß Message Discord r√©par√© pour la commande #${commande.numeroCommande} (statut: ${newStatut})`
        : `‚úÖ Action "${action}" effectu√©e avec succ√®s sur la commande #${commande.numeroCommande}`
      
      await interaction.editReply({ 
        content: confirmMessage
      })

      logger.info(`‚úÖ Interaction trait√©e avec succ√®s`)

    } catch (error) {
      // Nettoyer l'interaction du cache en cas d'erreur
      this.processedInteractions.delete(interaction.id)
      logger.error('‚ùå Erreur lors de la gestion de l\'interaction:', error)
      logger.error(`üéØ DEBUG: Type d'erreur: ${error.constructor.name}`)
      if (error instanceof Error) {
        logger.error(`   Message d'erreur: ${error.message}`)
        logger.error(`   Stack trace: ${error.stack}`)
      }
      logger.info(`üéØ DEBUG: √âtat de l'interaction:`)
      logger.info(`üéØ DEBUG: - deferred: ${interaction.deferred}`)
      logger.info(`üéØ DEBUG: - replied: ${interaction.replied}`)
      logger.info(`üéØ DEBUG: - isApplicationCommand: ${interaction.isButton()}`)
      
      try {
        logger.info(`üéØ DEBUG: Tentative de r√©ponse d'erreur...`)
        if (interaction.deferred) {
          logger.info(`üéØ DEBUG: Utilisation d'editReply pour l'erreur...`)
          await interaction.editReply({ 
            content: '‚ùå Une erreur est survenue lors du traitement'
          })
          logger.info(`üéØ DEBUG: ‚úÖ EditReply erreur r√©ussi`)
        } else if (!interaction.replied) {
          logger.info(`üéØ DEBUG: Utilisation de reply pour l'erreur...`)
          await interaction.reply({ 
            content: '‚ùå Une erreur est survenue lors du traitement', 
            flags: 64 // MessageFlags.Ephemeral
          })
          logger.info(`üéØ DEBUG: ‚úÖ Reply erreur r√©ussi`)
        } else {
          logger.info(`üéØ DEBUG: Interaction d√©j√† r√©pondue, pas de r√©ponse d'erreur envoy√©e`)
        }
      } catch (replyError) {
        logger.error('‚ùå Erreur lors de la r√©ponse d\'erreur:', replyError)
        logger.error(`üéØ DEBUG: Type d'erreur de r√©ponse: ${replyError.constructor.name}`)
        if (replyError instanceof Error) {
          logger.error(`üéØ DEBUG: Message erreur de r√©ponse: ${replyError.message}`)
        }
      }
    }
  }

  /**
   * Retourne l'emoji selon le statut
   */
  private getStatusEmoji(statut: string): string {
    switch (statut.toLowerCase()) {
      case 'en_attente':
        return '‚è≥'
      case 'confirmee':
        return '‚úÖ'
      case 'en_preparation':
        return 'üë®‚Äçüç≥'
      case 'prete':
        return 'üì¶'
      case 'livree':
        return 'üöö'
      case 'annulee':
        return '‚ùå'
      default:
        return '‚ùì'
    }
  }

  /**
   * Ferme la connexion Discord
   */
  public async shutdown(): Promise<void> {
    if (this.client) {
      await this.client.destroy()
      this.isConnected = false
      logger.info('Connexion Discord ferm√©e')
    }
  }
}

export default DiscordService.getInstance()
